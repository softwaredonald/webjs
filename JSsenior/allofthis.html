<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>函数的调用模式与this</title>

    <style>
    .s1{font-size:1.2em; color:darkblue;}
    .s2{font-size:1.5em; color:orange;}
    .s3{font-size:1.7em; color:red;}
    
    
    </style>

    
</head>
<body>
    <h1>四种调用模式的定义</h1>
    <p class="s1">
        <ol>
            <li>
                方法调用模式
                <ul>
                    <li>如果一个函数作为对象的一个方法属性调用，那么它的调用模式就是方法调用模式。</li>
                    <li><pre> var a = {}; a.toString();//方法调用模式 </pre></li>
                    <li>方法调用模式的this指向调用对象。</li>
                </ul>
            </li>
            <li>
                函数调用模式
                <ul>
                    <li>如果一个函数被直接调用。那么调用者歧视就是全局对象：window</li>
                    <li>函数调用模式this指向全局对象。</li>
                    <li><pre>function f() {}; f(); //函数调用模式</pre></li>
                </ul>
            </li>
            <li>构造器调用模式
                <ul>
                    <li>构造器调用模式就是构造函数调用</li>
                    <li>构造器模式调用必须有关键字new的存在</li>
                    <li>构造器模式调用的this指向创建出来的新对象。</li>
                    <li><pre> var t = new Dog();//构造器调用模式</pre></li>
                    <li>构造函数可以返回一个值，但是如果是简单类型会被忽略，如果是引用类型会替换掉新创建的对象返回</li>
                </ul>
            </li>
            <li>apply/call调用模式（借用方法模式）
                <ul>
                    <li>apply 和call可以改变函数调用的内部this的指向。</li>
                    <li>apply 和call的功能一样，只不过参数不一样，第一个参数都是改变函数内部的this的指向</li>
                    <li>第一个参数如果是null，undefined会被全局对象替代，如果是简单类型会被包装类型替代。</li>
                    <li>call第二个参数开始后面的都是传给函数的参数，可以有多个，用逗号隔开</li>
                    <li>apply第二个参数是一个传给函数的参数数组</li>
                    <li>调用：<pre>function m(a){}; m.call(window,2); m.apply(window,[2]);</pre></li>
                </ul>
            </li>
        </ol>

    </p>
</body>
</html>